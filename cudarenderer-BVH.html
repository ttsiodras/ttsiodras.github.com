<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="canonical" href="https://www.thanassis.space/cudarenderer-BVH.html">
<meta name="author" content="Thanassis Tsiodras">
<meta name="author" content="Athanasios Tsiodras">
<meta name="author" content="ttsiod">
<meta name="author" content="ttsiodras">
<link type="text/css" rel="stylesheet" href="final-code-wavetheory-lightbox.css">
<link rel="stylesheet" type="text/css" href="asciinema-player.css">
<link type="application/rss+xml" rel="alternate" href="rss.xml" title="Coding and administration articles by ttsiodras">
<script type="text/javascript" src="prototype.js"></script>
<script type="text/javascript" src="scriptaculous.js?load=effects,builder"></script>
<script type="text/javascript" src="lightbox.js"></script>
<script type="text/javascript" src="//apis.google.com/js/plusone.js">
    {lang:'en', parsetags:'explicit'}
</script>
<title>Renderer 2.x - Porting to CUDA (one month later)</title>
</head>
<body>
    <div class="well" id="Page">
        <div id="Banner">Renderer 2.x - Porting to CUDA (one month later)</div>
        <div id="MainContent">
            <div id="plusone-div" class="plusone"></div>
            <script type="text/javascript">gapi.plusone.render('plusone-div',{"size": "small", "count": "false"});</script>
            &nbsp;
            <a href="//www.reddit.com/r/programming/submit" onclick="window.location = window.location.protocol + '//www.reddit.com/r/programming/submit?url=' + encodeURIComponent(window.location); return false"> <img src="spreddit7.gif" alt="submit to programming reddit" border="0"> </a>
            <br>&nbsp;<br>
            <a href="https://github.com/ttsiodras/renderer-cuda"><img src="forkme_right_darkblue_121621.png" style="position: fixed; right: 0; top: 0;" alt="Fork me on GitHub"></a>

<div class="toc">
<ul class="nav nav-tabs nav-stacked">
<li><h4><b>Table of contents</b></h4></li>
<li><a href="#phase1">Phase 1: Raycasting</a></li>
<li><a href="#phase2">Phase 2: Raytracing</a></li>
<li><a href="#cudabvh">Moving the BVH to CUDA</a></li>
<li><a href="#recursion">CUDA recursion via templates</a></li>
<li><a href="#fix">Fixing the BVH</a></li>
<li><a href="#sse">BVH-building with SSE</a></li>
<li><a href="#templated">Templated features</a></li>
<li><a href="#speed">More speed!</a></li>
<li><a href="#features">Feature list</a></li>
<li><a href="#downloads">Downloads</a></li>
<li><a href="#compile1">Compilation under Linux</a></li>
<li><a href="#compile2">Compilation under Windows</a></li>
<li><a href="#keys">Keyboard controls</a></li>
<li><a href="#bench">Benchmark results</a></li>
</ul>
</div>
  <em>(February 2011, <a href="http://www.reddit.com/r/programming/comments/fgbfr/porting_my_renderer_from_c_to_cuda_a_journey/">Reddit-ed</a>)</em><br>
  <em>(April 2011, <a href="http://www.nvidia.co.uk/object/cuda_apps_flash_new_uk.html#">In CUDA Zone showcase...</a>)</em>
<br>&nbsp;<br>
It all started a month ago.<p>
It was the week between Xmas and the New Year, and I was enjoying my free time, hacking on <a href="renderer.html">my renderer</a> (a life-time obsession). Up till then, my renderer only included rasterizers, with soft-shadows and pre-calculated ambient occlusion:
  <table summary="Rendering a statue with a SW renderer">
  <tr>
  <td>
<!--object width="480" height="385"><param name="movie" value="http://www.youtube.com/v/M2cFz6190ZM&hl=en_US&fs=1&rel=0"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/M2cFz6190ZM&hl=en_US&fs=1&rel=0" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="480" height="385"></embed></object-->
<!--object type="application/x-shockwave-flash" style="width:480px;height:385px;" data="http://www.youtube.com/v/M2cFz6190ZM&amp;hl=en_US&amp;fs=1&amp;rel=0"><param name="movie" value="http://www.youtube.com/v/0FrAZis6Wfk"><param name="allowFullScreen" value="true"></object-->
<object type="application/x-shockwave-flash" style="width:480px;height:385px;" data="https://www.youtube.com/v/M2cFz6190ZM&amp;hl=en_US&amp;fs=1&amp;rel=0">
    <param name="movie" value="https://www.youtube.com/v/M2cFz6190ZM">
    <param name="allowFullScreen" value="true">
    <!-- Fallback content -->
    <a href="https://www.youtube.com/watch?v=M2cFz6190ZM">
    <img src="ajax-video.jpg" width="480" height="360" alt="Rendered statue">
    </a>
</object>
  </td></tr></table>
  <br>&nbsp;<br>
I wanted more, however. I had more or less completed everything I ever wanted to do with my rasterizers, since (a)&nbsp;all the features I ever wanted to implement were done (b)&nbsp;the code used a common C++ template to create a "family" of rasterizers (since all rasterizers share the same trait: they interpolate "stuff" linearly across the scanlines, per-pixel).
<p>
Since CUDA <a href="mandelSSE.html">promised to give me enough power to do it in real-time</a>, I decided to try raytracing, something I had never done before.
<a name="phase1"></a>
<h2>Phase 1: Raycasting</h2>
Raytracing has nothing to do with rasterizing - it is a completely different algorithm. It sends a ray from the viewpoint, that "pierces" the screen at each pixel, and checks whether the ray intersects the scene's triangles:
<pre>
for each screen pixel
        throw a ray from the viewpoint to the pixel
        find the closest triangle pierced by the ray
        at the intersection point, perform Phong lighting
</pre>
Or, if we also want shadows:
<pre>
for each screen pixel
        throw a ray from the viewpoint to the pixel
        find the closest triangle pierced by the ray
        at the intersection point, throw another ray towards the light
        if this shadow ray finds any triangle, the pixel is in shadow
        Otherwise, perform Phong lighting
</pre>
Raytracers can in fact work with more than just triangles - spheres and cylinders and other "perfect" objects can be traced. I have, however, always coded my renderer to work with triangle meshes - for a number of reasons (huge availability of ready-made 3D models being a good one). I therefore Googled for ray/triangle intersections. I knew I would need acceleration structures - if I was to make this run at real-time speeds, I had to avoid checking each ray against all the scene's triangles. 
<p>
A <a href="http://publications.lib.chalmers.se/records/fulltext/123790.pdf">thesis</a> drew my attention: two guys had implemented irregular Z-buffers in CUDA, using "bins" of triangle lists. It was simple enough: the screen was split in a grid of "bins", and after calculating the 2D bounding box of the projected (screen-space) triangle, we know which "bins" the triangle "spans" over...

<div class="scrollableContainer">
<img hspace="20" vspace="20" alt="Triangle bin spanning" src="binSpanning.png"><br>
<div><em>The triangles are placed in "bin" lists.</em></div>
</div>

...and we place the triangle in a simple <tt>std::list&lt;Triangle*&gt;</tt> (stored per each bin). When sending our rays, we only check for intersections with the triangles that belong in the ray's bin, not with all of them.
<p>
Well, CUDA didn't have STL lists of course, but I coped the old fashioned way, via heap (<tt>cudaMalloc</tt>-ed). And this worked - after about a day of coding, I had my first ever raycaster written:
  <table summary="Rendering: C++ vs CUDA" align="center">
  <tr>
  <td>
<center>
<!--object width="480" height="385"><param name="movie" value="http://www.youtube.com/v/0F1A3npCe4A&hl=en_US&fs=1&rel=0"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/0F1A3npCe4A&hl=en_US&fs=1&rel=0" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="480" height="385"></embed></object-->
<!--object type="application/x-shockwave-flash" style="width:480px;height:385px;" data="http://www.youtube.com/v/0F1A3npCe4A&amp;hl=en_US&amp;fs=1&amp;rel=0"><param name="movie" value="http://www.youtube.com/v/0F1A3npCe4A"><param name="allowFullScreen" value="true"></object-->
<object type="application/x-shockwave-flash" style="width:480px;height:385px;" data="https://www.youtube.com/v/0F1A3npCe4A&amp;hl=en_US&amp;fs=1&amp;rel=0">
    <param name="movie" value="https://www.youtube.com/v/0F1A3npCe4A">
    <param name="allowFullScreen" value="true">
    <!-- Fallback content -->
    <a href="https://www.youtube.com/watch?v=0F1A3npCe4A">
    <img src="dragon-video.jpg" width="480" height="360" alt="C++ vs CUDA raycasting">
    </a>
</object>
</center>
  </td></tr>
  <tr><td><center><em>A dragon... in C++ and in CUDA.</em></center></td></tr></table>
&nbsp;<br>
A 50K triangles "dragon" was raycasted at about 20 frames per second. Not bad for a days work!
<p>
Unfortunately, as the video shows, the speed nose-dived from 20 to about 1.5 frames per second, as soon as I added shadows. I was aghast. Why? I was using the same trick, that is, "bins" that store triangle lists, only this time I was calculating them in "light-screen" space. The same algorithm, but speed was devastated... because CUDA1.2 (i.e. my 70$ GT240) has no cache, and also suffers a lot from <a href="cudarenderer.html#divergence">thread divergence</a>.
<p>
So I <A href="http://www.reddit.com/r/programming/comments/euxzx/porting_my_renderer_from_c_to_cuda_the_speed/">posted this to Reddit</A>, hoping for advice. In 2 days, it became the <a href="http://goo.gl/cmGmmn">most popular CUDA post ever</a> in Reddit/ programming :&#x2011;) To be honest, some people there wanted to skin me alive. "How dare you implement shadows without OpenGL, you bloody idiot!" (or something to that effect).
<p>
But I persevered :&#x2011;)
<p>
Googling and reading papers, I found out about the balancing of global memory latency with more threads, so I wrote <a href="cudarenderer.html#threads">a quick Python script</a> to find the optimal balance between the number of bins I was using, and the number of threads per CUDA block. Rendering speed improved by a factor of 4!
<p>
<a href="cudarenderer.html#textures">Using textures</a> was next: CUDA1.2 (i.e. my GT240) has no cache, but if the data were placed in textures, they would be cached. A bit. I tried it, and only got 3% speedup...
<p>
So I went back to the code, and tried to make my global memory accesses more coalesced: I changed the screen size of the bins to directly mirror the number of CUDA blocks - this meant that each block of threads was accessing <b>exactly</b> the same triangle list, so global memory accesses became a lot more "streamlined". Speed soared by 2.5x.
<p>
And at that point, I realized it - I was doing raycasting, with Phong lighting and shadows, rendering a colorful train object at 21 frames per second!
<p>
Oh, the joy! :&#x2011;)
  <table summary="CUDA interactive raycasting" align="center">
  <tr>
  <td>
<center>
<!--object width="480" height="385"><param name="movie" value="http://www.youtube.com/v/0F1A3npCe4A&hl=en_US&fs=1&rel=0"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/0F1A3npCe4A&hl=en_US&fs=1&rel=0" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="480" height="385"></embed></object-->
<!--object type="application/x-shockwave-flash" style="width:480px;height:385px;" data="http://www.youtube.com/v/0F1A3npCe4A&amp;hl=en_US&amp;fs=1&amp;rel=0"><param name="movie" value="http://www.youtube.com/v/0F1A3npCe4A"><param name="allowFullScreen" value="true"></object-->
<object type="application/x-shockwave-flash" style="width:480px;height:385px;" data="https://www.youtube.com/v/Qzn0Ep4tvSI&amp;hl=en_US&amp;fs=1&amp;rel=0">
    <param name="movie" value="https://www.youtube.com/v/Qzn0Ep4tvSI">
    <param name="allowFullScreen" value="true">
    <!-- Fallback content -->
    <a href="https://www.youtube.com/watch?v=Qzn0Ep4tvSI">
    <img src="train-iphone.png" width="480" height="360" alt="CUDA interactive raycasting">
    </a>
</object>
</center>
  </td></tr></table>
<a name="phase2"></a>
<h2>Phase 2: Raytracing</h2>
Two weeks passed. And as you can probably guess, I wanted more. Again :)
<p>
It turned out, that the "bins" trick is not good enough. After all, a raytracer doesn't stop at the first intersection. It casts <a href="chessRaytraced.jpg" rel="lightbox" title="Reflections">reflected</a>, <a href="chessRefraction.jpg"  rel="lightbox" title="Refractions">refracted</a> and my favourite, <a href="ambientSponza.gif" rel="lightbox" title="Ambient occlusion">ambient occlusion rays</a>. Bins can't accomodate that. I needed a better data structure, a space partitioning scheme.
<p>
So I Googled again... and read about the <a href="http://en.wikipedia.org/wiki/Bounding_volume_hierarchy">Bounding Volume Hierarchy</a>, and how it can be used to accelerate any ray-intersection checking in world space. As I always do with a new graphics algorithm, I first coded it in my <a href="renderer.html">SW-only</a> version of the renderer. Furious coding ensued... and the results were beautiful, <a href="conference.jpg" rel="lightbox" title="Ambient occlusion slideshow">beyond</a> <a href="ambientSponza.gif" rel="lightbox" title="Ambient occlusion slideshow">anything</a> my rasterizers ever did. Were these images really created by my renderer? I couldn't believe it.
<p>
What I could believe, unfortunately, was the speed. Abysmal. The pure-C++ version gave me one frame per second on the train object (sigh).
<p>
This begged for the CUDA treatment.
<a name="cudabvh"></a>
<h3>Moving the BVH to CUDA land</h3>
A bounding volume hieararchy is a simple data structure, that "groups" objects together into bounding volumes. If a ray doesn't hit the volume, then you don't need to check whether it hits any objects inside it, and you are gaining tremendous speed.
<p>
The structure itself, however, is hierarchical - which is another way of saying "recursive". And guess what - CUDA doesn't have recursion. I had to switch to a stack-based recursive implementation for my ray traversals into the BVH. This turned out to be easier than I thought. I also changed the C++ version of BVH nodes (that had pointers to inner/leaf nodes inside them) into a far less C++-y version, storing indices in the CUDA arrays instead of pointers.

<div class='codegenWrapper'>
<pre><tt>
<span class="normal">    CacheFriendlyBVHNode</span><span class="symbol">*</span><span class="normal"> stack</span><span class="symbol">[</span><span class="normal">BVH_STACK_SIZE</span><span class="symbol">];</span>
<span class="normal">    </span><span class="type">int</span><span class="normal"> stackIdx </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    stack</span><span class="symbol">[</span><span class="normal">stackIdx</span><span class="symbol">++]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// index to the first BVH node</span>
<span class="normal">    </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">stackIdx</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="type">int</span><span class="normal"> boxIdx </span><span class="symbol">=</span><span class="normal"> stack</span><span class="symbol">[</span><span class="normal">stackIdx</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">	</span><span class="usertype">CacheFriendlyBVHNode</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">pCurrent </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">cudaBVHNodes</span><span class="symbol">[</span><span class="normal">boxIdx</span><span class="symbol">];</span>
<span class="normal">	stackIdx</span><span class="symbol">--;</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">pCurrent</span><span class="symbol">-&gt;</span><span class="function">IsLeaf</span><span class="symbol">())</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="symbol">...</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RayIntersectsBox</span><span class="symbol">(</span><span class="normal">origin</span><span class="symbol">,</span><span class="normal"> ray</span><span class="symbol">,</span><span class="normal"> pCurrent</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// Ray hits this box, put its children in the stack</span>
<span class="normal">		stack</span><span class="symbol">[</span><span class="normal">stackIdx</span><span class="symbol">++]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> pCurrent</span><span class="symbol">-&gt;</span><span class="normal">u</span><span class="symbol">.</span><span class="normal">inner</span><span class="symbol">.</span><span class="normal">_idxRight</span><span class="symbol">;</span>
<span class="normal">		stack</span><span class="symbol">[</span><span class="normal">stackIdx</span><span class="symbol">++]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> pCurrent</span><span class="symbol">-&gt;</span><span class="normal">u</span><span class="symbol">.</span><span class="normal">inner</span><span class="symbol">.</span><span class="normal">_idxLeft</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	</span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="comment">// Leaf node </span>
<span class="normal">	    </span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> i</span><span class="symbol">=</span><span class="normal">pCurrent</span><span class="symbol">-&gt;</span><span class="normal">u</span><span class="symbol">.</span><span class="normal">leaf</span><span class="symbol">.</span><span class="normal">_startIndexInTriIndexList</span><span class="symbol">;</span>
<span class="normal">	        i</span><span class="symbol">&lt;</span><span class="normal">pCurrent</span><span class="symbol">-&gt;</span><span class="normal">u</span><span class="symbol">.</span><span class="normal">leaf</span><span class="symbol">.</span><span class="normal">_startIndexInTriIndexList </span><span class="symbol">+</span><span class="normal"> pCurrent</span><span class="symbol">-&gt;</span><span class="normal">u</span><span class="symbol">.</span><span class="normal">leaf</span><span class="symbol">.</span><span class="normal">_count</span><span class="symbol">;</span>
<span class="normal">		i</span><span class="symbol">++)</span><span class="normal"> </span>
<span class="normal">	    </span><span class="comment">// check the triangle list...</span>

</tt></pre>

</div>
<p>I compiled, typed the command to spawn the raytracer, looked away from the screen, and hit ENTER...
<p>Would you believe me? It worked <em>the first time</em>. No joke. I spent two hours to change the C++ code into its CUDA equivalent, and it worked the first time I tried. Has only happened once or twice in my programming life...! Probably it was the side effect of the additional experience I had amassed in the meantime - regardless, I was positively giddy - this first attempt was running 3.5x times faster than the C++ code, showing reflections and shadows. I had 3.5 frames per second on the train now...
<p>
More! I needed more! :&#x2011;)
<p>
Looking at the code, I remembered about textures again. I had tried them in the "bins" version, two weeks ago, but they hadn't helped much there. I decided to try it again, and did a rather ugly hack of storing successive floating point numbers from my structures into successive <tt>float4</tt> elements of a CUDA texture. I did it for everything - vertices data texture, triangles data texture, pre-computed triangle intersection data texture, BVH data texture...
<p>
And at each step... Oh... my... God.
<p>
The speed was increasing by more than 50% each time I stored a new category of data in textures! I have no explanation as to why it had failed so miserably when I tried it with the bins - maybe I goofed somehow (most probably). The point is, that I finally had it - I had a raytracer running in real-time, showing me reflections and shadows, at about 15 frames per second!
  <table summary="CUDA interactive raytracing" align="center">
  <tr>
  <td>
<center>
<!--object width="480" height="385"><param name="movie" value="http://www.youtube.com/v/1o8HM11h8fc&hl=en_US&fs=1&rel=0"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/1o8HM11h8fc&hl=en_US&fs=1&rel=0" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="480" height="385"></embed></object-->
<!--object type="application/x-shockwave-flash" style="width:480px;height:385px;" data="http://www.youtube.com/v/1o8HM11h8fc&amp;hl=en_US&amp;fs=1&amp;rel=0"><param name="movie" value="http://www.youtube.com/v/1o8HM11h8fc"><param name="allowFullScreen" value="true"></object-->
<object type="application/x-shockwave-flash" style="width:480px;height:385px;" data="https://www.youtube.com/v/1o8HM11h8fc&amp;hl=en_US&amp;fs=1&amp;rel=0">
    <param name="movie" value="https://www.youtube.com/v/1o8HM11h8fc">
    <param name="allowFullScreen" value="true">
    <!-- Fallback content -->
    <a href="https://www.youtube.com/watch?v=1o8HM11h8fc">
    <img src="chess-iphone.jpg" width="480" height="360" alt="CUDA interactive raytracing">
    </a>
</object>
</center>
  </td></tr></table>
<a name="recursion"></a>
<h3>CUDA recursion via C++ templates</h3>
So far, I was using a stack-based recursion for traversing the BVH, but I was NOT using anything similar for the raytracer itself. I had something else in mind: C++ template meta-programming.
<p>
This is interesting, developer-wise, so have a look:
<pre>
Color Raytrace(int depth, const Vector3&amp; ray, const Vector3&amp; origin, ...)
{
    if (depth>MAX_RAY_DEPTH)
        return AmbientBlack;
    ....
    // Do full raytracing, find the closest intersection...
    // and recurse!
    ...
    return calculatedColorSoFar + Raytrace(depth+1, reflectionRay, intersectionPoint) + ....
}
</pre>
CUDA wouldn't allow this. "No recursion for you", Thanassis.<p>
So I changed it, to this:
<pre>
template &lt;int depth&gt;
Color Raytrace(const Vector3&amp; ray, const Vector3&amp; origin, ...)
{
    ....
    // Do full raytracing, find the closest intersection...
    // and recurse!
    ...
    return calculatedColorSoFar + Raytrace&lt;depth+1&gt;(reflectionRay, intersectionPoint) + ....
}

template&lt;&gt;
Color Raytrace&lt;MAX_RAY_DEPTH&gt;(const Vector3&amp; ray, const Vector3&amp; origin, ...)
{
    return AmbientBlack;
}
</pre>
Now, I don't know if you've seen template meta-programming before, but I consider this one of the best hacks I've ever written. I force the C++ compiler to create <em>different</em> versions of the Raytrace function, and each one calls another, not itself - so no problem compiling this with CUDA! 
<p>
The recursion ends when <tt>Raytrace&lt;MAX_RAY_DEPTH&gt;</tt> is called, which returns the ambient black I am using.
<a name="fix"></a>
<h3>Fix your BVH, stupid</h3>
The raytracer was already running in real-time. But I was noticing some strange things while flying in my scenes - sometimes, even when I was staring in a part of space that was decidedly empty, it was slow - when in fact it should have been at 30fps or more.
<p>
Debugging this was a LOT more difficult. It required logging (see the <tt>#ifdef DEBUG_LOG_BVH</tt> sections in the code) and extensive testing. I eventually found I had a bug in how I was building the BVH, and when I fixed it, speed almost doubled. Again :&#x2011;)
<p>
The train was now running at the same speed as the "bins" version, with Phong lighting, Phong normal interpolation, and both shadows and reflections enabled. And the code was actually... much better looking.
<p>
Except for one thing - the right BVH... took more time to build. The chessboard needed 34 seconds to load...
<a name="sse"></a>
<h3>BVH-building with SSE</h3>
I had coded SSE before (in my <a href="mandelSSE.html">Mandelbrot</a> zoomer), so it was clear to me that building the BVH and continually taking the min and max of floating point coordinates while building bounding boxes, was a prime candidate for <tt>_mm_min_ps</tt> and <tt>_mm_max_ps</tt>. If you are not aware of them, SSE instructions work on 4 floats at a time, and could therefore be used to accelerate my BVH building a lot.
<p>
I had worked with SSE before, but I had not used intrinsics - this time, I chose to be more portable and avoid inline assembly. A day's worth of work later (because turning something to SSE is not as easy as writing it in CUDA) I finished it - and the chessboard was now loading in 10 seconds.
<p>
As fate would have it, as soon as I finished with that, I realized I could simply store the calculated BVH data the first time I load an object, and re-load them (from the saved "cache") next time. Even the slow version of the BVH calculation would be fine with that.
<p>
Sometimes the simple ideas come too late :&#x2011;)
<p>
(<em>Future plans: dynamic scenes via runtime creation of BVH with CUDA</em>)
<a name="templated"></a>
<h3>Templated features</h3>
Since C++ templates are compile-time code generators, I realized I could move beyond the "rendering modes" of my <a href="renderer.html">SW-only</a> renderer. I could choose different rendering parameters at runtime, by changing the core CUDA kernel into a template:
<pre>
template &lt;bool doSpecular, bool doPhongNormals, bool doReflections, bool doShadows, bool antialias&gt;
__global__ void CoreLoopTrianglesRaycaster(
    int *pixels,
    ...
</pre>
...and use state-toggling booleans to invoke a different template each time:
<pre>
#define PAINT(bDoSpecular,bDoPhongInterp,bDoReflections,bDoShadows,bDoAntialias)  \
    CoreLoopTrianglesRaycaster&lt;                                                   \
        bDoSpecular,                                                              \
        bDoPhongInterp,                                                           \
        bDoReflections,                                                           \
        bDoShadows,                                                               \
        bDoAntialias&gt;                                                             \
    &lt;&lt;&lt; blockPixels, THREADS_PER_BLOCK &gt;&gt;&gt;(                                       \
    ...

if (!g_bUseSpecular &amp;&amp; !g_bUsePhongInterp &amp;&amp; !g_bUseReflections &amp;&amp; \
        !g_bUseShadows &amp;&amp; !g_bUseAntialiasing) {
   PAINT( false , false , false , false , false )
} else if (!g_bUseSpecular &amp;&amp; !g_bUsePhongInterp &amp;&amp; !g_bUseReflections &amp;&amp; \
        !g_bUseShadows &amp;&amp; g_bUseAntialiasing) {
   PAINT( false , false , false , false , true )
} else if (!g_bUseSpecular &amp;&amp; !g_bUsePhongInterp &amp;&amp; !g_bUseReflections &amp;&amp; \
        g_bUseShadows &amp;&amp; !g_bUseAntialiasing) {
   PAINT( false , false , false , true , false )
...
</pre>
What this means, is that each time the compiler sees a PAINT macro invocation, a specific template is instantiated,
with just the features we want - at compile-time! And the result is that we can switch raytracer features on and off,
at run-time, without the penalty of executing these if statements at run-time, in the body of the CUDA kernel.
<p>
Have I mentioned how I love C++ templates?
<p>
OK, here's a gripe about them, so you won't call me a fanboy of Stroustrup: When the template params are booleans and/or enumerants, I shouldn't have to resort to such hacks - I should be able to say...
<pre>
CoreLoopTrianglesRaycaster&lt;
    g_bDoSpecular,
    g_bDoPhongInterp,
    g_bDoReflections,
    g_bDoShadows,
    g_bDoAntialias&gt;(...);
</pre>
...and it should work. After all, how difficult is it for the compiler to create the 2^5 (32) different versions of
the Raytracing function?
<p>
Am I asking for too much?
<p>
(<em>I know I am. And naturally, I didn't write the 32 if statements by hand - I wrote a Python script that wrote
them for me</em>).
<a name="speed"></a>
<h3>More speed!</h3>
The hunt for more speed continues - feel free to send suggestions my way. 
<p>A result to compare with: the latest version of my raytracer, renders the well-known "Conference" scene with primary rays, diffuse lighting and shadows at 22 frames per second. Not bad, I think. The train object is also running at 18 frames per second with reflections, shadows, Phong normal interpolation and specular lighting.
<a name="features"></a>
<h2>Features of the raytracer</h2>
For those of you that skipped the developer gobbledygook above, here's a short list of my raytracer's features:
  <ul>
  <li>Real-time raytracing of triangle meshes - my 70$ GT240 renders a 67K triangles chessboard with Phong lighting, Phong normal interpolation, reflections and shadows at 15-20 frames per second. Interactive navigation and rendering mode changes are allowed (see video below). Overall, compared to the <a href="renderer.html">pure C++/OpenMP</a> version, the CUDA implementation runs 10-20 times faster.</li>
  <li>A Bounding Volume Hierarchy using axis-aligned bounding boxes is created and used for ray/triangle intersections. The BVH is created via the surface-area heuristic, and is stored for fast re-use. If SSE extensions are detected during compilation (from <tt>configure</tt>), then a SIMD implementation is used at load-time that builds the BVH faster.</li>
  <li>CUDA 1.2 cards like my GT240 have no support for recursion, so I used C++ template magic to implement compile-time recursion - see <tt>cudarenderer.cu</tt> in the source tarball for details.</li>
  <li>C++ template-based configuration allows for no-penalty runtime selection of (a) specular lighting (b) Phong interpolation of normals (c) backface culling (e.g. not used in refractions) (d) reflections (e) shadows (f) anti-aliasing.</li>
  <li>Z-order curve is used to cast the primary rays (Morton order) - significantly less divergence => more speed.</li>
  <li>Vertices, triangles and BVH data are stored in textures - major speed boost.</li>
  <li>Screen and keyboard handling is done via libSDL, for portability (runs fine under Windows/Linux/etc)</li>
  <li>The code is GPL, and uses autoconf/automake for easy builds under Linux. For windows, the required MSVC project files are included, so the build is just as easy (see instructions below).
  </ul>
  <table summary="CUDA interactive raytracing" align="center">
  <tr>
  <td>
<center>
<!--object width="480" height="385"><param name="movie" value="http://www.youtube.com/v/1o8HM11h8fc&hl=en_US&fs=1&rel=0"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/1o8HM11h8fc&hl=en_US&fs=1&rel=0" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="480" height="385"></embed></object-->
<!--object type="application/x-shockwave-flash" style="width:480px;height:385px;" data="http://www.youtube.com/v/1o8HM11h8fc&amp;hl=en_US&amp;fs=1&amp;rel=0"><param name="movie" value="http://www.youtube.com/v/1o8HM11h8fc"><param name="allowFullScreen" value="true"></object-->
<object type="application/x-shockwave-flash" style="width:480px;height:385px;" data="https://www.youtube.com/v/1o8HM11h8fc&amp;hl=en_US&amp;fs=1&amp;rel=0">
    <param name="movie" value="https://www.youtube.com/v/1o8HM11h8fc">
    <param name="allowFullScreen" value="true">
    <!-- Fallback content -->
    <a href="https://www.youtube.com/watch?v=1o8HM11h8fc">
    <img src="chess-iphone.jpg" width="480" height="360" alt="CUDA interactive raytracing">
    </a>
</object>
</center>
  </td></tr></table>
<a name="downloads"></a>
<h2>Downloads</h2>
The code is under the GPL, and lives in <a href="https://github.com/ttsiodras/renderer-cuda">GitHub</a>. Here's <a href="https://github.com/ttsiodras/renderer-cuda/archive/v2.1k.tar.gz">a tarball with the latest source code</a> (<em>last update: 2.1k, December 2015 - made it work with CUDA toolset version 6.0.37)</em>.<p>
<a href="cudarenderer-2.x.latest-win32.7z">Win32 binaries</a> are also available (compressed <a href="http://www.7-zip.org/">with 7-zip</a>), with 2 sample 3D objects bundled. For more 3D objects, download the source tarball of my <a href="renderer.html">SW-only version</a>.
<a name="compile1"></a>
<h3>Compilation under Linux</h3>
The code has 3 dependencies: You must have installed OpenGL (with GLEW and GLUT), libSDL and the CUDA toolkit.
If you are using Debian,  the first two are covered with:

<pre>
sudo apt-get install libsdl1.2-dev libglew1.5-dev freeglut3-dev mesa-common-dev
</pre>

...and the second is also quite easy - add the <code>contrib</code> and <code>non-free</code>
collections to <code>/etc/apt/sources.list</code> - that is, at the end of your distro's
repository line. In my case, it looks like this after editing:

<pre>
    deb http://ftp.gr.debian.org/debian/ jessie main non-free contrib
</pre>

...and then:

<pre>
    <b>bash$</b> sudo apt-get install nvidia-cuda-dev nvidia-cuda-toolkit
    <b>bash$</b> dpkg -l | grep nvidia-cuda
    ii  nvidia-cuda-dev      6.0.37-5  amd64  NVIDIA CUDA development files
    ii  nvidia-cuda-toolkit  6.0.37-5  amd64  NVIDIA CUDA development toolkit
</pre>

After installing the dependencies, a simple...

<pre>
    <b>bash$</b> ./configure && make 
</pre>

...followed by...

<pre>
    <b>bash$</b> ./src/cudaRenderer 3D-objects/chessboard.tri 
</pre>

...will show you a rotating chessboard, with Phong lighting, Phong normal interpolation, reflections and shadows, like the video shown above.
<p>
Read below for keyboard control intructions, or just press 'H' for help.
<a name="compile2"></a>
<h3>Compilation under Windows</h3>
Make sure you have the CUDA toolkit installed (I used version 6.0). Then:
<ol>
<li>Open the VisualC/cudaRenderer_vc90.sln with your Visual Studio
<li>Compile in Release mode
<li>Right-click on "cudaRenderer" in the Solution explorer, and select "Properties"
<li>Click on "Configuration Properties/Debugging"
<li>In the "Command Arguments", enter "..\3D-objects\chessboard.tri" and click OK
<li>Hit Ctrl-F5 to run.
</ol>

You should see a rotating chessboard... 

Read below for keyboard control intructions, or just press 'H' for help.
<p>
<em>Note: I used the free Visual C++ 2008 Express Edition, but this should work 
with the commercial one, too.</em>

<a name="keys"></a>
<h3>Keyboard controls</h3>
You can navigate in realtime:
  <ul>
  <li>Hit 'R' to stop/start auto-spin.
  <li>Use the cursor keys, 'A' and 'Z' to pilot. Don't be afraid to press multiple keys together.
  <li>Rotate the light with 'W', 'Q'.
  <li>'S' and 'F' are 'strafe' left/right, 'E' and 'D' are 'strafe' up/down.<br>
  (strafe keys don't work in auto-spin mode).
  <li>Raytracer configuration:
  <ul>
    <li>F4 toggles points mode
    <li>F5 toggles specular lighting
    <li>F6 toggles phong normal interpolation
    <li>F7 toggles reflections
    <li>F8 toggles shadows
    <li>F9 toggles anti-aliasing
  </ul>
  <li>ESC quits.
  </ul>
<a name="bench"></a>
<h3>Benchmark results</h3>
Some results <a href="http://forums.nvidia.com/index.php?showtopic=192596">sent by users of the raytracer</a> on the chess scene. Note that speed depends on many factors, not just the chip used (e.g. memory clock speed, etc).
<ul>
<li>Quadro FX 580 (Cuda 1.1): 3 fps 
<li>GTS 250 (Cuda 1.1): 11.9 fps
<li>GT  240 (Cuda 1.2): 18.5 fps
<li>GTX 295 (Cuda 1.3): 21 fps
<li>GTS 450 (Cuda 2.1): 19 fps (double-homed system, with buffer copies between cards)
<li>GTX 470 (Cuda 2.0): 45 fps (double-homed system, with buffer copies between cards)
<li>GTX 470 (Cuda 2.0): 64.2 fps (standalone, no buffer copies)
<li>GTX 580 (Cuda 2.0): 51 fps
<li>GTX 580 (Cuda 2.0, mem/4008 MHz, shaders/1544 Mhz): 73.64 fps
<li>GTX 580 (Cuda 2.0, mem/4600 MHz, shaders/1800 MHz): 83.01 fps
</ul>
Keep them coming!
<br>
    <hr>
    <div style='margin-top:1em'>
        <div style='float:left'>
            <a target="_blank" href="https://stackoverflow.com/users/382050/ttsiodras">
                <img src="382050.png" width="208" height="58" alt="profile for ttsiodras at Stack Overflow, Q&amp;A for professional and enthusiast programmers" title="profile for ttsiodras at Stack Overflow, Q&amp;A for professional and enthusiast programmers">
            </a>
        </div>
        <div style='float:left; margin-left:1em'>
            <a target="_blank" href="https://github.com/ttsiodras">
                <img border="1" src="github.png" alt='GitHub member ttsiodras' title='GitHub member ttsiodras'>
            </a>
        </div>
        <!--div style='float:left; margin-left:1em'>
            <a target="_blank" href="https://projecteuler.net/profile/ttsiodras.png">
                <img src="https://projecteuler.net/profile/ttsiodras.png" alt='Project Euler member ttsiodras' title='Project Euler member ttsiodras'>
            </a>
        </div-->
    </div>
    <div style='clear:both; margin-bottom:0.5em'></div>

<!-- Used to do this with float:right, but Opera Mini shows nothing with it... back to tables :-( -->
<table summary="Footer" width="100%" border="0"><tr><td><a href="index.html">Back to index</a>&nbsp;&nbsp;<a href="cv.pdf">My CV</a>&nbsp;&nbsp;<a href="https://plus.google.com/+ThanassisTsiodras/about">About me</a></td><td align="right"><em>Last update on: Sat Nov 19 10:10:45 2016</em>&nbsp;(<a href="//validator.w3.org/check?uri=referer"><em>Valid HTML</em></a>)</td></tr></table>

            <hr style="margin-bottom: 1em">
            <script src="urchin.js" type="text/javascript"></script>
            <script type="text/javascript">_uacct = "UA-746316-1";urchinTracker();</script>
            <p id="disqus_thread">
                The comments on this website require the use of JavaScript. Perhaps your browser isn't
                JavaScript capable or the script is not being run for another reason. If you're
                interested in reading the comments or leaving a comment behind please try again with a
                different browser or from a different connection.
            </p>
            <script type="text/javascript">
                /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                var disqus_shortname = 'ttsiodras';
                var disqus_identifier = '../content/cudarenderer-BVH.content';

                (function() {
                    'use strict';

                    /**
                     * This method will handle the click on the button to load the comments. It will remove the
                     * button and execute the original Disqus script for loading the comments.
                     */
                    function button_clickHandler(event) {
                        // We need to get the button element, we could also use the target property of the event
                        // but this will do just as well
                        var button = document.getElementById('disqus_thread');
                        // Now we will have to recreate the div element we removed from the HTML. We will place
                        // it into the DOM like we did when we created the button
                        var disqusContainer = document.createElement('div');
                        button.parentNode.insertBefore(disqusContainer, button);
                        button.parentNode.removeChild(button);

                        // The div element will need to have the disqus_thread id as this is required for Disqus,
                        // it is the way their code identifies the element in which the comments can be displayed
                        disqusContainer.id = 'disqus_thread';

                        // Now we can execute the original Disqus code
                        var dsq = document.createElement('script');
                        dsq.type = 'text/javascript';
                        dsq.async = true;
                        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                    }

                    /**
                     * This method will initialize the module. It will replace the JavaScript dependency message
                     * with a button which will allow the visitor to load the comments.
                     */
                    function init() {
                        // Try to get the element we used to display the message about the JavaScript dependency
                        var placeholder = document.getElementById('disqus_thread');
                        // If we didn't get the placeholder element we will stop setting up the button to load
                        // the comments
                        if (placeholder == null) {
                            return;
                        }

                        // The placeholder was found, now we can create the button which will allow the visitor to
                        // load the comments
                        var button = document.createElement('button');
                        button.appendChild(document.createTextNode('Click here to see the comments (powered by Disqus)'));
                        button.addEventListener('click', button_clickHandler.bind(this));

                        // We will insert the button before the placeholder and once the button has been placed in
                        // the DOM we will remove the placeholder
                        placeholder.parentNode.insertBefore(button, placeholder);
                        placeholder.parentNode.removeChild(placeholder);

                        // The placeholder used to have the id which can be reference by an anchor element, to make
                        // sure we don't break this functionality we will apply the id to our newly created button
                        button.id = 'disqus_thread';
                    }

                    // Setup the module
                    init();
                })();
            </script>
        </div>
    </div>
</body>
</html>
